# 7장: 분산 시스템을 위한 유일 ID 생성기 설계

**학습 날짜:** 2025년 12월 17일 

## 1. 개요

분산 시스템에서 유일성이 보장되는 ID를 생성하는 것은 필수적입니다. 단순히 DB의 기능을 사용하는 방법부터 분산 환경에 최적화된 방식까지 다양한 전략이 존재합니다.


## 2. 데이터베이스 자동 증가 (Auto-Increment)

보통 관계형 데이터베이스(RDBMS)의 `AUTO_INCREMENT`(MySQL) 또는 `SERIAL`(PostgreSQL) 기능을 이용합니다.

* **원리:** 새 레코드가 삽입될 때마다 DB가 값을 1씩 증가시키며 유일성을 보장합니다.
* **장점:** 구현이 매우 쉽고, 생성 순서에 따라 정렬되어 인덱싱 성능이 우수합니다.

* **AUTO_INCREMENT와 인덱스 성능:**
  * PK 설정 시 **Clustered Index**가 생성되어 물리적으로 레코드를 정렬합니다.
  * 이메일 같은 변동 폭이 큰 값을 PK로 쓰면 삽입 시 대규모 데이터 재정렬이 필요하지만, ID를 사용하면 순차 삽입이 가능해 성능에 유리합니다.



* **단점:** * **SPOF (Single Point of Failure):** DB 서버 다운 시 전체 시스템의 쓰기 작업이 중단됩니다.
* **확장성 저하:** 여러 서버로 확장하기 어렵고 네트워크 지연이 발생할 수 있습니다.
* **보안:** ID를 통해 데이터 규모나 생성 속도가 노출될 수 있습니다.


## 3. 다중 마스터 복제 (Multi-master Replication)

여러 개의 DB 서버를 두고 각 서버가 생성하는 ID 값을 다르게 설정하는 방식입니다.

* **원리:** DB 서버의 개수(K)만큼 ID를 건너뛰며 증가시킵니다 (예: 서버1은 1, 3, 5... 서버2는 2, 4, 6...).
* **장점:** 중복 ID 생성을 방지하고 가용성을 높입니다.
* **단점:** 서버 추가/삭제 시 대응이 어렵고, 전체적인 시간 흐름에 따른 정렬을 보장하기 힘듭니다.


## 4. UUID (Universally Unique Identifier)

128비트 크기의 수를 사용하여 유일성을 식별하는 방식입니다.

* **특징:** 충돌 가능성이 0에 가깝게 설계되었습니다.
* **단점:** 128비트로 길어 DB 용량을 차지하며, 전통적으로 시간순 정렬이 어렵습니다.
* **UUID v7:** 최근 버전인 v7은 상위 48비트에 **Unix Timestamp**를 배치하여 정렬 성능을 개선했습니다.

## 5. 티켓 서버 (Ticket Server)

중앙에 ID 생성만을 담당하는 전용 데이터베이스(티켓 서버)를 두는 방식입니다.

* **장점:** 유일성이 확실하게 보장됩니다.
* **단점:** 티켓 서버 자체가 **SPOF**가 될 수 있어 고가용성 대응이 어렵습니다.

## 6. 트위터 스노플레이크 (Snowflake)

64비트 ID를 생성하며, 분산 환경에서 정렬 가능성과 유일성을 모두 잡은 방식입니다.

### ID 구조 (총 64비트 / 8바이트)

| 구성 요소 | 비트 수 | 설명 |
| --- | --- | --- |
| **사인 비트** | 1비트 | 항상 0으로 설정하여 음수 오류 방지 및 정렬 보장 |
| **타임스탬프** | 41비트 | 밀리초 단위 시간 정보 (약 69년 사용 가능) |
| **데이터센터 ID** | 5비트 | 최대 32개의 데이터센터 지원 |
| **서버 ID** | 5비트 | 데이터센터당 최대 32개의 서버 지원 |
| **일련번호** | 12비트 | 동일 밀리초 내에서 생성되는 ID를 구분 (최대 4096개)|

### 정렬 보장 방식

* 기본적으로 **타임스탬프**가 시간 순으로 증가하며, 동일 시간대에는 **일련번호**를 증가시켜 전체적인 오름차순 정렬을 유지합니다.

