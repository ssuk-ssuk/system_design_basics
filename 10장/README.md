# 10장: 알림 시스템 설계

**학습 날짜:** 2026년 1월 14일 

## 1. 개요

알림 시스템은 사용자에게 중요할 만한 정보를 **비동기적**으로 제공하며, 고객 서비스와의 접점을 유지하는 핵심 기능을 수행합니다.


## 2. 알림 유형 및 서비스별 지원 방안

알림은 크게 4가지 유형으로 분류되며, 각 OS 및 서비스 벤더를 경유하여 전달됩니다.

| 종류 | 핵심 전송 서비스 (제3자 서비스) | 특징 |
| --- | --- | --- |
| **모바일 푸시** | iOS: APNS, Android: FCM | 스마트폰 팝업/배지 표시. FCM은 크로스 플랫폼 지원이 강력함. |
| **SMS/메신저** | Twilio, 알림톡, WhatsApp | 앱 미설치자 대상. 카카오 알림톡은 국내 정보성 메시지에 최적화. |
| **이메일** | AWS SES, SendGrid, Mailgun | 마케팅, 인증용. 전송 성공률(Deliverability) 관리가 중요함. |
| **웹 푸시** | 브라우저 벤더 서버 | Service Worker를 사용하여 백그라운드에서도 수신 가능. |


## 3. 개략적 설계 및 개선안

초기 설계에서는 알림 시스템 서버가 모든 처리를 담당하지만, 확장성과 안정성을 위해 다음과 같이 개선합니다.

* 
**컴포넌트 분리**: 데이터베이스와 캐시를 주 서버에서 분리하여 응답 속도 향상.


* 
**메시지 큐 도입**: 시스템 컴포넌트 간의 강한 결합을 끊고 지연 처리를 지원.


* 
**수평적 확장**: 알림 서버를 증설하여 대규모 트래픽(하루 1,000만 건 이상) 대응.


## 4. 상세 설계 및 안정성 확보

4.1 데이터 손실 방지 (At-least-once) 

* **알림 로그 선(先) 저장**: 큐에 넣기 전 DB에 `PENDING` 상태로 먼저 기록 (Outbox Pattern).
* **수동 ACK (Manual Acknowledgement)**: 워커가 실제 발송 성공 후 큐에 신호를 보내 메시지를 삭제하도록 설정.
* **재시도 및 DLQ**: 실패 시 **지수 백오프**로 재시도하고, 최종 실패 건은 **죽은 편지함(DLQ)**으로 이동.

4.2 알림 중복 전송 방지 (Idempotency) 

분산 시스템에서는 '정확히 한 번' 전송이 불가능하므로 **멱등성** 로직으로 대응합니다.

1. **고유 ID 생성**: 비즈니스 로직과 연관된 고유 키 생성 (예: 주문번호 + 타입).
2. **Redis SETNX**: "검사 후 선점" 방식으로 이미 처리 중이거나 완료된 키는 무시.
3. **DB Unique Key**: Redis 장애를 대비해 DB 수준에서 2차 방어.

### 4.3 기타 기능 최적화

* **알림 템플릿**: 자주 변하지 않는 문구 양식을 캐싱하여 I/O 비용 절감.
* **전송률 제한 (Rate Limiting)**: 스팸 방지를 위해 사용자당 알림 빈도를 Redis Counter로 제어.
* **보안**: 알림 전송 API 호출 시 비밀키(`appKey`, `appSecret`) 사용.


## 5. 핵심 결론: "Fake Exactly-once" 

물리적으로 메시지가 여러 번 전송될 수 있음을 인정하고, 애플리케이션 레벨에서 이를 1번만 처리된 것처럼 보이게 하는 것이 핵심입니다.

> 
> **공식: 최소 1회 전송 (At-least-once) + 멱등성 (Idempotency) = 정확히 1회 처리 (Exactly-once Processing)** 
> 
> 

| 관점 | 실제로 일어난 일 | 최종 인식 |
| --- | --- | --- |
| **네트워크** | 메시지 N회 전송 | At-least-once |
| **비즈니스 로직** | 첫 번째만 실행, 이후 스킵 | <br>**Exactly-once (환상)** |
| **사용자 경험** | 알림 1번 수신 | 만족 |
