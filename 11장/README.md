# 11장 뉴스 피드 시스템 설계 핵심 요약

### 1. 개요 및 요구사항

- **뉴스 피드**: 페이스북, 인스타그램처럼 친구들의 소식을 시간 순으로 모아보는 기능.
- **핵심 트래픽**: DAU 1,000만 명, 팔로잉 수 최대 5,000명 가정.
- **주요 프로세스**: **피드 발행(Write)**과 **피드 읽기(Read)** 두 가지로 나뉩니다.

### 2. 피드 발행 및 갱신 모델 (Fan-out)

사용자의 새 글을 친구들에게 배달하는 방식에는 3가지 모델이 있습니다.

1.  **Push 모델 (Fan-out on Write)**

- **방식**: 글을 쓰는 순간 팔로워들의 피드 캐시에 미리 데이터를 넣어둠.
- **장점**: 피드 읽기 속도가 매우 빠름 (이미 만들어져 있음).
- **단점**: 팔로워가 많은 인플루언서(Hot Key)의 경우 작성 시 부하가 심각함 (Hot-Key 문제).

2.  **Pull 모델 (Fan-out on Read)**

- **방식**: 피드를 읽는 시점에 친구들의 최신 글을 가져와 합침.
- **장점**: 글 작성 시 부하가 없고 Hot Key 문제가 발생하지 않음.
- **단점**: 피드를 읽을 때마다 데이터를 계산해야 하므로 읽기 속도가 느림.

3.  **하이브리드 구조 (권장)**

- **일반 사용자**: Push 모델 적용 (빠른 읽기 보장).
- **인플루언서**: Pull 모델 적용 (시스템 부하 방지).
- **조회 시**: Push된 피드와 Pull로 가져온 인플루언서 글을 병합하여 보여줌.

### 3. 캐시 전략 (Redis)

DB 부하를 줄이고 빠른 응답을 위해 Redis를 적극 활용합니다.

- **Hot-Key 해결**: 인플루언서의 타임라인은 여러 Redis 샤드(Shard)에 복제하여 읽기 부하를 분산함.
- **자료구조 벤치마크**:
- **String**: 수정/삭제 시 전체 역직렬화 필요하여 매우 느림.
- **List**: 중간 데이터 삭제가 O(N)으로 느리고 시간순 정렬 보장이 어려움.
- **Hash**: 가장 빠르지만 정렬이 불가능함.
- **Sorted Set (ZSet)**: **가장 적합**. 점수(Score) 기반 자동 정렬, O(log N)의 안정적 성능 제공.

### 4. 메시지 큐 (Message Queue) 도입

- **Write 병목 해소**: 글 작성 시 동기적으로 처리하면 느려지므로, MQ를 통해 비동기로 처리하여 사용자 응답 속도 향상.
- **결합도 감소**: 서비스 간 의존성을 줄이고 장애 격리 효과.
- **안정성**: 작업 실패 시 재시도(Retry) 및 DLQ 처리 가능.

### 5. 그래프 데이터베이스 (Graph DB) 활용

복잡한 관계 데이터를 처리할 때 RDB의 한계를 극복하기 위해 사용합니다.

- **RDB의 문제점**: "친구의 친구" 같은 N단계 관계 조회 시 JOIN이 기하급수적으로 늘어나 성능 저하.
- **그래프 DB (Neo4j) 장점**:
- **관계 중심**: JOIN 없이 노드 간 연결(Edge)을 따라가므로 깊이와 상관없이 일정한 성능 유지.
- **성능 비교**: 5단계 친구 조회 시 MySQL은 45초, Neo4j는 0.08초 소요 (약 562배 차이).
- **직관성**: Cypher 쿼리를 사용하여 복잡한 패턴(친구 추천 등)을 자연어처럼 쉽게 작성 가능.

### 6. 최종 아키텍처 제언 (Hybrid Architecture)

- **RDB (MySQL)**: 사용자 정보, 게시글 등 마스터 데이터 저장.
- **Graph DB (Neo4j)**: 팔로우 관계, 친구 추천 알고리즘 등 관계 데이터 처리.
- **Redis**: 뉴스 피드 ID 및 자주 조회되는 데이터 캐싱.
- 소셜 미디어 서비스에서 그래프 DB는 선택이 아닌 필수 요소임.
